// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// SHA-256 SYNC - Use for hot paths and small data
/// ~1-5µs for typical inputs
U8Array32 sha256Sync({required List<int> data}) =>
    RustLib.instance.api.crateSha256Sync(data: data);

/// SHA-512 SYNC
U8Array64 sha512Sync({required List<int> data}) =>
    RustLib.instance.api.crateSha512Sync(data: data);

/// SHA-1 SYNC
U8Array20 sha1Sync({required List<int> data}) =>
    RustLib.instance.api.crateSha1Sync(data: data);

/// SHA-384 SYNC
U8Array48 sha384Sync({required List<int> data}) =>
    RustLib.instance.api.crateSha384Sync(data: data);

/// SHA-224 SYNC
U8Array28 sha224Sync({required List<int> data}) =>
    RustLib.instance.api.crateSha224Sync(data: data);

/// MD5 SYNC - WARNING: Cryptographically broken
U8Array16 md5Sync({required List<int> data}) =>
    RustLib.instance.api.crateMd5Sync(data: data);

/// SHA-512/256 SYNC
U8Array32 sha512256Sync({required List<int> data}) =>
    RustLib.instance.api.crateSha512256Sync(data: data);

/// SHA-512/224 SYNC
U8Array28 sha512224Sync({required List<int> data}) =>
    RustLib.instance.api.crateSha512224Sync(data: data);

/// SHA-256 ASYNC - Use for large data to avoid UI blocking
Future<U8Array32> sha256Async({required List<int> data}) =>
    RustLib.instance.api.crateSha256Async(data: data);

Future<U8Array64> sha512Async({required List<int> data}) =>
    RustLib.instance.api.crateSha512Async(data: data);

Future<U8Array20> sha1Async({required List<int> data}) =>
    RustLib.instance.api.crateSha1Async(data: data);

Future<U8Array48> sha384Async({required List<int> data}) =>
    RustLib.instance.api.crateSha384Async(data: data);

Future<U8Array16> md5Async({required List<int> data}) =>
    RustLib.instance.api.crateMd5Async(data: data);

/// HMAC-SHA256 SYNC - Hardware accelerated, ~2-8µs
U8Array32 hmacSha256Sync({required List<int> key, required List<int> data}) =>
    RustLib.instance.api.crateHmacSha256Sync(key: key, data: data);

/// HMAC-SHA512 SYNC
U8Array64 hmacSha512Sync({required List<int> key, required List<int> data}) =>
    RustLib.instance.api.crateHmacSha512Sync(key: key, data: data);

/// HMAC-SHA1 SYNC
U8Array20 hmacSha1Sync({required List<int> key, required List<int> data}) =>
    RustLib.instance.api.crateHmacSha1Sync(key: key, data: data);

/// HMAC-SHA384 SYNC
U8Array48 hmacSha384Sync({required List<int> key, required List<int> data}) =>
    RustLib.instance.api.crateHmacSha384Sync(key: key, data: data);

/// HMAC-SHA224 SYNC
U8Array28 hmacSha224Sync({required List<int> key, required List<int> data}) =>
    RustLib.instance.api.crateHmacSha224Sync(key: key, data: data);

/// HMAC-MD5 SYNC - WARNING: Cryptographically broken
U8Array16 hmacMd5Sync({required List<int> key, required List<int> data}) =>
    RustLib.instance.api.crateHmacMd5Sync(key: key, data: data);

Future<U8Array32> hmacSha256Async({
  required List<int> key,
  required List<int> data,
}) => RustLib.instance.api.crateHmacSha256Async(key: key, data: data);

Future<U8Array64> hmacSha512Async({
  required List<int> key,
  required List<int> data,
}) => RustLib.instance.api.crateHmacSha512Async(key: key, data: data);

/// AES-256-GCM SYNC Encryption - Returns raw ciphertext bytes
/// ~50-150µs for <2KB data
Uint8List? aes256EncryptSync({
  required List<int> plaintext,
  required List<int> key,
}) =>
    RustLib.instance.api.crateAes256EncryptSync(plaintext: plaintext, key: key);

/// AES-256-GCM SYNC Decryption - Takes raw ciphertext bytes
Uint8List? aes256DecryptSync({
  required List<int> ciphertext,
  required List<int> key,
}) => RustLib.instance.api.crateAes256DecryptSync(
  ciphertext: ciphertext,
  key: key,
);

Future<Uint8List?> aes256EncryptAsync({
  required List<int> plaintext,
  required List<int> key,
}) => RustLib.instance.api.crateAes256EncryptAsync(
  plaintext: plaintext,
  key: key,
);

Future<Uint8List?> aes256DecryptAsync({
  required List<int> ciphertext,
  required List<int> key,
}) => RustLib.instance.api.crateAes256DecryptAsync(
  ciphertext: ciphertext,
  key: key,
);

/// Hash multiple inputs in one FFI call - HUGE performance win
/// Example: 1000 hashes in ~5ms instead of ~50ms
List<U8Array32> sha256BatchSync({required List<Uint8List> inputs}) =>
    RustLib.instance.api.crateSha256BatchSync(inputs: inputs);

/// HMAC batch processing
List<U8Array32> hmacSha256BatchSync({
  required List<int> key,
  required List<Uint8List> messages,
}) =>
    RustLib.instance.api.crateHmacSha256BatchSync(key: key, messages: messages);

/// Hash then encrypt in one operation - saves FFI roundtrip
Uint8List? hashThenEncryptSync({
  required List<int> data,
  required List<int> key,
}) => RustLib.instance.api.crateHashThenEncryptSync(data: data, key: key);

/// Encrypt then HMAC (Encrypt-then-MAC pattern)
(Uint8List, U8Array32)? encryptThenMacSync({
  required List<int> plaintext,
  required List<int> encKey,
  required List<int> macKey,
}) => RustLib.instance.api.crateEncryptThenMacSync(
  plaintext: plaintext,
  encKey: encKey,
  macKey: macKey,
);

/// Verify MAC then decrypt
Uint8List? verifyThenDecryptSync({
  required List<int> ciphertext,
  required List<int> mac,
  required List<int> encKey,
  required List<int> macKey,
}) => RustLib.instance.api.crateVerifyThenDecryptSync(
  ciphertext: ciphertext,
  mac: mac,
  encKey: encKey,
  macKey: macKey,
);

/// Convert bytes to hex string - do this in Rust to avoid Dart overhead
String toHexSync({required List<int> bytes}) =>
    RustLib.instance.api.crateToHexSync(bytes: bytes);

/// Convert hex string to bytes
Uint8List? fromHexSync({required String hexString}) =>
    RustLib.instance.api.crateFromHexSync(hexString: hexString);

/// Get hash output size in bytes
BigInt hashSizeSync({required String algorithm}) =>
    RustLib.instance.api.crateHashSizeSync(algorithm: algorithm);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<HmacSha256State>>
abstract class HmacSha256State implements RustOpaqueInterface {
  U8Array32 finalize();

  factory HmacSha256State({required List<int> key}) =>
      RustLib.instance.api.crateHmacSha256StateNew(key: key);

  void update({required List<int> data});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sha256Hasher>>
abstract class Sha256Hasher implements RustOpaqueInterface {
  U8Array32 finalize();

  factory Sha256Hasher() => RustLib.instance.api.crateSha256HasherNew();

  void update({required List<int> data});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sha512Hasher>>
abstract class Sha512Hasher implements RustOpaqueInterface {
  U8Array64 finalize();

  factory Sha512Hasher() => RustLib.instance.api.crateSha512HasherNew();

  void update({required List<int> data});
}

class U8Array16 extends NonGrowableListView<int> {
  static const arraySize = 16;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array16(this._inner) : assert(_inner.length == arraySize), super(_inner);

  U8Array16.init() : this(Uint8List(arraySize));
}

class U8Array20 extends NonGrowableListView<int> {
  static const arraySize = 20;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array20(this._inner) : assert(_inner.length == arraySize), super(_inner);

  U8Array20.init() : this(Uint8List(arraySize));
}

class U8Array28 extends NonGrowableListView<int> {
  static const arraySize = 28;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array28(this._inner) : assert(_inner.length == arraySize), super(_inner);

  U8Array28.init() : this(Uint8List(arraySize));
}

class U8Array32 extends NonGrowableListView<int> {
  static const arraySize = 32;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array32(this._inner) : assert(_inner.length == arraySize), super(_inner);

  U8Array32.init() : this(Uint8List(arraySize));
}

class U8Array48 extends NonGrowableListView<int> {
  static const arraySize = 48;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array48(this._inner) : assert(_inner.length == arraySize), super(_inner);

  U8Array48.init() : this(Uint8List(arraySize));
}

class U8Array64 extends NonGrowableListView<int> {
  static const arraySize = 64;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array64(this._inner) : assert(_inner.length == arraySize), super(_inner);

  U8Array64.init() : this(Uint8List(arraySize));
}
