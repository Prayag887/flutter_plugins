// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:collection/collection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `hmac_md5_internal`, `hmac_sha1_internal`, `hmac_sha224_internal`, `hmac_sha256_internal`, `hmac_sha384_internal`, `hmac_sha512_internal`, `md5_internal`, `sha1_internal`, `sha224_internal`, `sha256_internal`, `sha384_internal`, `sha512_224_internal`, `sha512_256_internal`, `sha512_internal`

U8Array32 sha256({required List<int> data}) =>
    RustLib.instance.api.crateSha256(data: data);

Future<U8Array32> sha256Async({required List<int> data}) =>
    RustLib.instance.api.crateSha256Async(data: data);

U8Array64 sha512({required List<int> data}) =>
    RustLib.instance.api.crateSha512(data: data);

Future<U8Array64> sha512Async({required List<int> data}) =>
    RustLib.instance.api.crateSha512Async(data: data);

U8Array20 sha1({required List<int> data}) =>
    RustLib.instance.api.crateSha1(data: data);

Future<U8Array20> sha1Async({required List<int> data}) =>
    RustLib.instance.api.crateSha1Async(data: data);

U8Array48 sha384({required List<int> data}) =>
    RustLib.instance.api.crateSha384(data: data);

Future<U8Array48> sha384Async({required List<int> data}) =>
    RustLib.instance.api.crateSha384Async(data: data);

U8Array28 sha224({required List<int> data}) =>
    RustLib.instance.api.crateSha224(data: data);

Future<U8Array28> sha224Async({required List<int> data}) =>
    RustLib.instance.api.crateSha224Async(data: data);

U8Array16 md5({required List<int> data}) =>
    RustLib.instance.api.crateMd5(data: data);

Future<U8Array16> md5Async({required List<int> data}) =>
    RustLib.instance.api.crateMd5Async(data: data);

U8Array32 sha512256({required List<int> data}) =>
    RustLib.instance.api.crateSha512256(data: data);

Future<U8Array32> sha512256Async({required List<int> data}) =>
    RustLib.instance.api.crateSha512256Async(data: data);

U8Array28 sha512224({required List<int> data}) =>
    RustLib.instance.api.crateSha512224(data: data);

Future<U8Array28> sha512224Async({required List<int> data}) =>
    RustLib.instance.api.crateSha512224Async(data: data);

U8Array32 hmacSha256({required List<int> key, required List<int> data}) =>
    RustLib.instance.api.crateHmacSha256(key: key, data: data);

Future<U8Array32> hmacSha256Async({
  required List<int> key,
  required List<int> data,
}) => RustLib.instance.api.crateHmacSha256Async(key: key, data: data);

U8Array64 hmacSha512({required List<int> key, required List<int> data}) =>
    RustLib.instance.api.crateHmacSha512(key: key, data: data);

Future<U8Array64> hmacSha512Async({
  required List<int> key,
  required List<int> data,
}) => RustLib.instance.api.crateHmacSha512Async(key: key, data: data);

U8Array20 hmacSha1({required List<int> key, required List<int> data}) =>
    RustLib.instance.api.crateHmacSha1(key: key, data: data);

Future<U8Array20> hmacSha1Async({
  required List<int> key,
  required List<int> data,
}) => RustLib.instance.api.crateHmacSha1Async(key: key, data: data);

U8Array48 hmacSha384({required List<int> key, required List<int> data}) =>
    RustLib.instance.api.crateHmacSha384(key: key, data: data);

Future<U8Array48> hmacSha384Async({
  required List<int> key,
  required List<int> data,
}) => RustLib.instance.api.crateHmacSha384Async(key: key, data: data);

U8Array28 hmacSha224({required List<int> key, required List<int> data}) =>
    RustLib.instance.api.crateHmacSha224(key: key, data: data);

Future<U8Array28> hmacSha224Async({
  required List<int> key,
  required List<int> data,
}) => RustLib.instance.api.crateHmacSha224Async(key: key, data: data);

U8Array16 hmacMd5({required List<int> key, required List<int> data}) =>
    RustLib.instance.api.crateHmacMd5(key: key, data: data);

Future<U8Array16> hmacMd5Async({
  required List<int> key,
  required List<int> data,
}) => RustLib.instance.api.crateHmacMd5Async(key: key, data: data);

Uint8List? aes256Encrypt({
  required List<int> plaintext,
  required List<int> key,
}) => RustLib.instance.api.crateAes256Encrypt(plaintext: plaintext, key: key);

Future<Uint8List?> aes256EncryptAsync({
  required List<int> plaintext,
  required List<int> key,
}) => RustLib.instance.api.crateAes256EncryptAsync(
  plaintext: plaintext,
  key: key,
);

Uint8List? aes256Decrypt({
  required List<int> ciphertext,
  required List<int> key,
}) => RustLib.instance.api.crateAes256Decrypt(ciphertext: ciphertext, key: key);

Future<Uint8List?> aes256DecryptAsync({
  required List<int> ciphertext,
  required List<int> key,
}) => RustLib.instance.api.crateAes256DecryptAsync(
  ciphertext: ciphertext,
  key: key,
);

List<U8Array32> sha256Batch({required List<Uint8List> inputs}) =>
    RustLib.instance.api.crateSha256Batch(inputs: inputs);

Future<List<U8Array32>> sha256BatchAsync({required List<Uint8List> inputs}) =>
    RustLib.instance.api.crateSha256BatchAsync(inputs: inputs);

List<U8Array64> sha512Batch({required List<Uint8List> inputs}) =>
    RustLib.instance.api.crateSha512Batch(inputs: inputs);

Future<List<U8Array64>> sha512BatchAsync({required List<Uint8List> inputs}) =>
    RustLib.instance.api.crateSha512BatchAsync(inputs: inputs);

List<U8Array32> hmacSha256Batch({
  required List<int> key,
  required List<Uint8List> messages,
}) => RustLib.instance.api.crateHmacSha256Batch(key: key, messages: messages);

Future<List<U8Array32>> hmacSha256BatchAsync({
  required List<int> key,
  required List<Uint8List> messages,
}) => RustLib.instance.api.crateHmacSha256BatchAsync(
  key: key,
  messages: messages,
);

List<U8Array64> hmacSha512Batch({
  required List<int> key,
  required List<Uint8List> messages,
}) => RustLib.instance.api.crateHmacSha512Batch(key: key, messages: messages);

Future<List<U8Array64>> hmacSha512BatchAsync({
  required List<int> key,
  required List<Uint8List> messages,
}) => RustLib.instance.api.crateHmacSha512BatchAsync(
  key: key,
  messages: messages,
);

Uint8List? hashThenEncrypt({required List<int> data, required List<int> key}) =>
    RustLib.instance.api.crateHashThenEncrypt(data: data, key: key);

Future<Uint8List?> hashThenEncryptAsync({
  required List<int> data,
  required List<int> key,
}) => RustLib.instance.api.crateHashThenEncryptAsync(data: data, key: key);

(Uint8List, U8Array32)? encryptThenHmac({
  required List<int> plaintext,
  required List<int> encKey,
  required List<int> macKey,
}) => RustLib.instance.api.crateEncryptThenHmac(
  plaintext: plaintext,
  encKey: encKey,
  macKey: macKey,
);

Future<(Uint8List, U8Array32)?> encryptThenHmacAsync({
  required List<int> plaintext,
  required List<int> encKey,
  required List<int> macKey,
}) => RustLib.instance.api.crateEncryptThenHmacAsync(
  plaintext: plaintext,
  encKey: encKey,
  macKey: macKey,
);

Uint8List? verifyHmacThenDecrypt({
  required List<int> ciphertext,
  required List<int> mac,
  required List<int> encKey,
  required List<int> macKey,
}) => RustLib.instance.api.crateVerifyHmacThenDecrypt(
  ciphertext: ciphertext,
  mac: mac,
  encKey: encKey,
  macKey: macKey,
);

Future<Uint8List?> verifyHmacThenDecryptAsync({
  required List<int> ciphertext,
  required List<int> mac,
  required List<int> encKey,
  required List<int> macKey,
}) => RustLib.instance.api.crateVerifyHmacThenDecryptAsync(
  ciphertext: ciphertext,
  mac: mac,
  encKey: encKey,
  macKey: macKey,
);

String toHex({required List<int> bytes}) =>
    RustLib.instance.api.crateToHex(bytes: bytes);

Uint8List? fromHex({required String hexString}) =>
    RustLib.instance.api.crateFromHex(hexString: hexString);

BigInt hashSize({required String algorithm}) =>
    RustLib.instance.api.crateHashSize(algorithm: algorithm);

List<String> getAllAlgorithms() => RustLib.instance.api.crateGetAllAlgorithms();

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sha1Hasher>>
abstract class Sha1Hasher implements RustOpaqueInterface {
  U8Array20 finalize();

  factory Sha1Hasher() => RustLib.instance.api.crateSha1HasherNew();

  void update({required List<int> data});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sha256Hasher>>
abstract class Sha256Hasher implements RustOpaqueInterface {
  U8Array32 finalize();

  factory Sha256Hasher() => RustLib.instance.api.crateSha256HasherNew();

  void update({required List<int> data});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sha256HmacHasher>>
abstract class Sha256HmacHasher implements RustOpaqueInterface {
  U8Array32 finalize();

  factory Sha256HmacHasher({required List<int> key}) =>
      RustLib.instance.api.crateSha256HmacHasherNew(key: key) ??
          (throw StateError('Failed to create Sha256HmacHasher'));

  void update({required List<int> data});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Sha512Hasher>>
abstract class Sha512Hasher implements RustOpaqueInterface {
  U8Array64 finalize();

  factory Sha512Hasher() => RustLib.instance.api.crateSha512HasherNew();

  void update({required List<int> data});
}

class U8Array16 extends NonGrowableListView<int> {
  static const arraySize = 16;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array16(this._inner) : assert(_inner.length == arraySize), super(_inner);

  U8Array16.init() : this(Uint8List(arraySize));
}

class U8Array20 extends NonGrowableListView<int> {
  static const arraySize = 20;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array20(this._inner) : assert(_inner.length == arraySize), super(_inner);

  U8Array20.init() : this(Uint8List(arraySize));
}

class U8Array28 extends NonGrowableListView<int> {
  static const arraySize = 28;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array28(this._inner) : assert(_inner.length == arraySize), super(_inner);

  U8Array28.init() : this(Uint8List(arraySize));
}

class U8Array32 extends NonGrowableListView<int> {
  static const arraySize = 32;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array32(this._inner) : assert(_inner.length == arraySize), super(_inner);

  U8Array32.init() : this(Uint8List(arraySize));
}

class U8Array48 extends NonGrowableListView<int> {
  static const arraySize = 48;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array48(this._inner) : assert(_inner.length == arraySize), super(_inner);

  U8Array48.init() : this(Uint8List(arraySize));
}

class U8Array64 extends NonGrowableListView<int> {
  static const arraySize = 64;

  @internal
  Uint8List get inner => _inner;
  final Uint8List _inner;

  U8Array64(this._inner) : assert(_inner.length == arraySize), super(_inner);

  U8Array64.init() : this(Uint8List(arraySize));
}
