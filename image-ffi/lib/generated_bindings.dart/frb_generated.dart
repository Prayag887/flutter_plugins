// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'image_manipulation.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => 1569716691;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'flutter_image_loader',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<void> crateImageManipulationImageCacheAddWatermark(
      {required ImageCache that,
      required int handle,
      required int watermarkHandle,
      required WatermarkParams params});

  Future<void> crateImageManipulationImageCacheAdjustAll(
      {required ImageCache that,
      required int handle,
      required AdjustmentParams params});

  Future<void> crateImageManipulationImageCacheAdjustBrightness(
      {required ImageCache that, required int handle, required int value});

  Future<void> crateImageManipulationImageCacheAdjustContrast(
      {required ImageCache that, required int handle, required int value});

  Future<void> crateImageManipulationImageCacheAdjustHue(
      {required ImageCache that, required int handle, required int value});

  Future<void> crateImageManipulationImageCacheAdjustSaturation(
      {required ImageCache that, required int handle, required int value});

  Future<void> crateImageManipulationImageCacheApplyFilter(
      {required ImageCache that,
      required int handle,
      required FilterType filter});

  Future<void> crateImageManipulationImageCacheBlur(
      {required ImageCache that, required int handle, required double sigma});

  Future<void> crateImageManipulationImageCacheClearAll(
      {required ImageCache that});

  Future<void> crateImageManipulationImageCacheCrop(
      {required ImageCache that,
      required int handle,
      required CropParams params});

  Future<void> crateImageManipulationImageCacheFlipHorizontal(
      {required ImageCache that, required int handle});

  Future<void> crateImageManipulationImageCacheFlipVertical(
      {required ImageCache that, required int handle});

  Future<Uint8List> crateImageManipulationImageCacheGetBytes(
      {required ImageCache that,
      required int handle,
      required ImageFormat format});

  Future<(int, int)> crateImageManipulationImageCacheGetDimensions(
      {required ImageCache that, required int handle});

  Future<CacheStats> crateImageManipulationImageCacheGetStats(
      {required ImageCache that});

  Future<void> crateImageManipulationImageCacheGrayscale(
      {required ImageCache that, required int handle});

  Future<void> crateImageManipulationImageCacheInvert(
      {required ImageCache that, required int handle});

  Future<int> crateImageManipulationImageCacheLoadFromBytes(
      {required ImageCache that, required List<int> bytes});

  Future<int> crateImageManipulationImageCacheLoadFromPath(
      {required ImageCache that, required String path});

  Future<ImageCache> crateImageManipulationImageCacheNew();

  Future<void> crateImageManipulationImageCacheOverlay(
      {required ImageCache that,
      required int handle,
      required int overlayHandle,
      required int x,
      required int y,
      required double opacity});

  Future<void> crateImageManipulationImageCacheRemove(
      {required ImageCache that, required int handle});

  Future<void> crateImageManipulationImageCacheResize(
      {required ImageCache that,
      required int handle,
      required int width,
      required int height,
      required ResizeFilter filter});

  Future<void> crateImageManipulationImageCacheResizeToFill(
      {required ImageCache that,
      required int handle,
      required int width,
      required int height,
      required ResizeFilter filter});

  Future<void> crateImageManipulationImageCacheResizeToFit(
      {required ImageCache that,
      required int handle,
      required int maxWidth,
      required int maxHeight,
      required ResizeFilter filter});

  Future<void> crateImageManipulationImageCacheRotate(
      {required ImageCache that, required int handle, required int degrees});

  Future<void> crateImageManipulationImageCacheSharpen(
      {required ImageCache that, required int handle, required double amount});

  Future<ImageCache> crateImageManipulationImageCacheWithMemoryLimit(
      {required BigInt maxMemoryBytes});

  Future<void> crateAddWatermark(
      {required int handle,
      required int watermarkHandle,
      required WatermarkParams params});

  Future<void> crateAdjustAll(
      {required int handle, required AdjustmentParams params});

  Future<void> crateAdjustBrightness({required int handle, required int value});

  Future<void> crateAdjustContrast({required int handle, required int value});

  Future<void> crateAdjustHue({required int handle, required int value});

  Future<void> crateAdjustSaturation({required int handle, required int value});

  Future<AdjustmentParams> crateImageManipulationAdjustmentParamsDefault();

  Future<void> crateApplyFilter(
      {required int handle, required FilterType filter});

  Future<void> crateBatchCropResizeAdjust(
      {required int handle,
      required CropParams cropParams,
      required int width,
      required int height,
      required ResizeFilter resizeFilter,
      required AdjustmentParams adjustments});

  Future<void> crateBatchResizeAndFilter(
      {required int handle,
      required int width,
      required int height,
      required ResizeFilter filter,
      required FilterType imageFilter});

  Future<void> crateBlur({required int handle, required double sigma});

  Future<void> crateClearAllImages();

  Future<void> crateCrop({required int handle, required CropParams params});

  Future<void> crateDisposeImage({required int handle});

  Future<void> crateDisposeImages({required List<int> handles});

  Future<void> crateFlipHorizontal({required int handle});

  Future<void> crateFlipVertical({required int handle});

  Future<CacheStats> crateGetCacheStats();

  Future<Uint8List> crateGetImageBytes(
      {required int handle, required ImageFormat format});

  Future<(int, int)> crateGetImageDimensions({required int handle});

  Future<void> crateGrayscale({required int handle});

  Future<void> crateInitCache({required BigInt maxMemoryMb});

  Future<void> crateInitializeCache();

  Future<void> crateInvert({required int handle});

  Future<int> crateLoadImageFromBytes({required List<int> bytes});

  Future<int> crateLoadImageFromPath({required String path});

  Future<void> crateOverlay(
      {required int handle,
      required int overlayHandle,
      required int x,
      required int y,
      required double opacity});

  Future<void> crateResize(
      {required int handle,
      required int width,
      required int height,
      required ResizeFilter filter});

  Future<void> crateResizeToFill(
      {required int handle,
      required int width,
      required int height,
      required ResizeFilter filter});

  Future<void> crateResizeToFit(
      {required int handle,
      required int maxWidth,
      required int maxHeight,
      required ResizeFilter filter});

  Future<void> crateRotate({required int handle, required int degrees});

  Future<void> crateSharpen({required int handle, required double amount});

  Future<WatermarkParams> crateImageManipulationWatermarkParamsDefault();

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ImageCache;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ImageCache;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ImageCachePtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<void> crateImageManipulationImageCacheAddWatermark(
      {required ImageCache that,
      required int handle,
      required int watermarkHandle,
      required WatermarkParams params}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        sse_encode_u_32(watermarkHandle, serializer);
        sse_encode_box_autoadd_watermark_params(params, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheAddWatermarkConstMeta,
      argValues: [that, handle, watermarkHandle, params],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheAddWatermarkConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_add_watermark",
        argNames: ["that", "handle", "watermarkHandle", "params"],
      );

  @override
  Future<void> crateImageManipulationImageCacheAdjustAll(
      {required ImageCache that,
      required int handle,
      required AdjustmentParams params}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        sse_encode_box_autoadd_adjustment_params(params, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheAdjustAllConstMeta,
      argValues: [that, handle, params],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheAdjustAllConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_adjust_all",
        argNames: ["that", "handle", "params"],
      );

  @override
  Future<void> crateImageManipulationImageCacheAdjustBrightness(
      {required ImageCache that, required int handle, required int value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        sse_encode_i_32(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheAdjustBrightnessConstMeta,
      argValues: [that, handle, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateImageManipulationImageCacheAdjustBrightnessConstMeta =>
          const TaskConstMeta(
            debugName: "ImageCache_adjust_brightness",
            argNames: ["that", "handle", "value"],
          );

  @override
  Future<void> crateImageManipulationImageCacheAdjustContrast(
      {required ImageCache that, required int handle, required int value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        sse_encode_i_32(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheAdjustContrastConstMeta,
      argValues: [that, handle, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheAdjustContrastConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_adjust_contrast",
        argNames: ["that", "handle", "value"],
      );

  @override
  Future<void> crateImageManipulationImageCacheAdjustHue(
      {required ImageCache that, required int handle, required int value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        sse_encode_i_32(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheAdjustHueConstMeta,
      argValues: [that, handle, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheAdjustHueConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_adjust_hue",
        argNames: ["that", "handle", "value"],
      );

  @override
  Future<void> crateImageManipulationImageCacheAdjustSaturation(
      {required ImageCache that, required int handle, required int value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        sse_encode_i_32(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheAdjustSaturationConstMeta,
      argValues: [that, handle, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateImageManipulationImageCacheAdjustSaturationConstMeta =>
          const TaskConstMeta(
            debugName: "ImageCache_adjust_saturation",
            argNames: ["that", "handle", "value"],
          );

  @override
  Future<void> crateImageManipulationImageCacheApplyFilter(
      {required ImageCache that,
      required int handle,
      required FilterType filter}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        sse_encode_filter_type(filter, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheApplyFilterConstMeta,
      argValues: [that, handle, filter],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheApplyFilterConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_apply_filter",
        argNames: ["that", "handle", "filter"],
      );

  @override
  Future<void> crateImageManipulationImageCacheBlur(
      {required ImageCache that, required int handle, required double sigma}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        sse_encode_f_32(sigma, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheBlurConstMeta,
      argValues: [that, handle, sigma],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheBlurConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_blur",
        argNames: ["that", "handle", "sigma"],
      );

  @override
  Future<void> crateImageManipulationImageCacheClearAll(
      {required ImageCache that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateImageManipulationImageCacheClearAllConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheClearAllConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_clear_all",
        argNames: ["that"],
      );

  @override
  Future<void> crateImageManipulationImageCacheCrop(
      {required ImageCache that,
      required int handle,
      required CropParams params}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        sse_encode_box_autoadd_crop_params(params, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheCropConstMeta,
      argValues: [that, handle, params],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheCropConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_crop",
        argNames: ["that", "handle", "params"],
      );

  @override
  Future<void> crateImageManipulationImageCacheFlipHorizontal(
      {required ImageCache that, required int handle}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheFlipHorizontalConstMeta,
      argValues: [that, handle],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheFlipHorizontalConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_flip_horizontal",
        argNames: ["that", "handle"],
      );

  @override
  Future<void> crateImageManipulationImageCacheFlipVertical(
      {required ImageCache that, required int handle}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheFlipVerticalConstMeta,
      argValues: [that, handle],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheFlipVerticalConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_flip_vertical",
        argNames: ["that", "handle"],
      );

  @override
  Future<Uint8List> crateImageManipulationImageCacheGetBytes(
      {required ImageCache that,
      required int handle,
      required ImageFormat format}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        sse_encode_image_format(format, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheGetBytesConstMeta,
      argValues: [that, handle, format],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheGetBytesConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_get_bytes",
        argNames: ["that", "handle", "format"],
      );

  @override
  Future<(int, int)> crateImageManipulationImageCacheGetDimensions(
      {required ImageCache that, required int handle}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_u_32_u_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheGetDimensionsConstMeta,
      argValues: [that, handle],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheGetDimensionsConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_get_dimensions",
        argNames: ["that", "handle"],
      );

  @override
  Future<CacheStats> crateImageManipulationImageCacheGetStats(
      {required ImageCache that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_cache_stats,
        decodeErrorData: null,
      ),
      constMeta: kCrateImageManipulationImageCacheGetStatsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheGetStatsConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_get_stats",
        argNames: ["that"],
      );

  @override
  Future<void> crateImageManipulationImageCacheGrayscale(
      {required ImageCache that, required int handle}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheGrayscaleConstMeta,
      argValues: [that, handle],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheGrayscaleConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_grayscale",
        argNames: ["that", "handle"],
      );

  @override
  Future<void> crateImageManipulationImageCacheInvert(
      {required ImageCache that, required int handle}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheInvertConstMeta,
      argValues: [that, handle],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheInvertConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_invert",
        argNames: ["that", "handle"],
      );

  @override
  Future<int> crateImageManipulationImageCacheLoadFromBytes(
      {required ImageCache that, required List<int> bytes}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_list_prim_u_8_loose(bytes, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheLoadFromBytesConstMeta,
      argValues: [that, bytes],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheLoadFromBytesConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_load_from_bytes",
        argNames: ["that", "bytes"],
      );

  @override
  Future<int> crateImageManipulationImageCacheLoadFromPath(
      {required ImageCache that, required String path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheLoadFromPathConstMeta,
      argValues: [that, path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheLoadFromPathConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_load_from_path",
        argNames: ["that", "path"],
      );

  @override
  Future<ImageCache> crateImageManipulationImageCacheNew() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache,
        decodeErrorData: null,
      ),
      constMeta: kCrateImageManipulationImageCacheNewConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheNewConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_new",
        argNames: [],
      );

  @override
  Future<void> crateImageManipulationImageCacheOverlay(
      {required ImageCache that,
      required int handle,
      required int overlayHandle,
      required int x,
      required int y,
      required double opacity}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        sse_encode_u_32(overlayHandle, serializer);
        sse_encode_i_32(x, serializer);
        sse_encode_i_32(y, serializer);
        sse_encode_f_32(opacity, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheOverlayConstMeta,
      argValues: [that, handle, overlayHandle, x, y, opacity],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheOverlayConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_overlay",
        argNames: ["that", "handle", "overlayHandle", "x", "y", "opacity"],
      );

  @override
  Future<void> crateImageManipulationImageCacheRemove(
      {required ImageCache that, required int handle}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheRemoveConstMeta,
      argValues: [that, handle],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheRemoveConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_remove",
        argNames: ["that", "handle"],
      );

  @override
  Future<void> crateImageManipulationImageCacheResize(
      {required ImageCache that,
      required int handle,
      required int width,
      required int height,
      required ResizeFilter filter}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        sse_encode_u_32(width, serializer);
        sse_encode_u_32(height, serializer);
        sse_encode_resize_filter(filter, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheResizeConstMeta,
      argValues: [that, handle, width, height, filter],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheResizeConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_resize",
        argNames: ["that", "handle", "width", "height", "filter"],
      );

  @override
  Future<void> crateImageManipulationImageCacheResizeToFill(
      {required ImageCache that,
      required int handle,
      required int width,
      required int height,
      required ResizeFilter filter}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        sse_encode_u_32(width, serializer);
        sse_encode_u_32(height, serializer);
        sse_encode_resize_filter(filter, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheResizeToFillConstMeta,
      argValues: [that, handle, width, height, filter],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheResizeToFillConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_resize_to_fill",
        argNames: ["that", "handle", "width", "height", "filter"],
      );

  @override
  Future<void> crateImageManipulationImageCacheResizeToFit(
      {required ImageCache that,
      required int handle,
      required int maxWidth,
      required int maxHeight,
      required ResizeFilter filter}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        sse_encode_u_32(maxWidth, serializer);
        sse_encode_u_32(maxHeight, serializer);
        sse_encode_resize_filter(filter, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheResizeToFitConstMeta,
      argValues: [that, handle, maxWidth, maxHeight, filter],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheResizeToFitConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_resize_to_fit",
        argNames: ["that", "handle", "maxWidth", "maxHeight", "filter"],
      );

  @override
  Future<void> crateImageManipulationImageCacheRotate(
      {required ImageCache that, required int handle, required int degrees}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        sse_encode_i_32(degrees, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheRotateConstMeta,
      argValues: [that, handle, degrees],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheRotateConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_rotate",
        argNames: ["that", "handle", "degrees"],
      );

  @override
  Future<void> crateImageManipulationImageCacheSharpen(
      {required ImageCache that, required int handle, required double amount}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
            that, serializer);
        sse_encode_u_32(handle, serializer);
        sse_encode_f_32(amount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateImageManipulationImageCacheSharpenConstMeta,
      argValues: [that, handle, amount],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheSharpenConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_sharpen",
        argNames: ["that", "handle", "amount"],
      );

  @override
  Future<ImageCache> crateImageManipulationImageCacheWithMemoryLimit(
      {required BigInt maxMemoryBytes}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(maxMemoryBytes, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache,
        decodeErrorData: null,
      ),
      constMeta: kCrateImageManipulationImageCacheWithMemoryLimitConstMeta,
      argValues: [maxMemoryBytes],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationImageCacheWithMemoryLimitConstMeta =>
      const TaskConstMeta(
        debugName: "ImageCache_with_memory_limit",
        argNames: ["maxMemoryBytes"],
      );

  @override
  Future<void> crateAddWatermark(
      {required int handle,
      required int watermarkHandle,
      required WatermarkParams params}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_u_32(watermarkHandle, serializer);
        sse_encode_box_autoadd_watermark_params(params, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateAddWatermarkConstMeta,
      argValues: [handle, watermarkHandle, params],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateAddWatermarkConstMeta => const TaskConstMeta(
        debugName: "add_watermark",
        argNames: ["handle", "watermarkHandle", "params"],
      );

  @override
  Future<void> crateAdjustAll(
      {required int handle, required AdjustmentParams params}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_box_autoadd_adjustment_params(params, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateAdjustAllConstMeta,
      argValues: [handle, params],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateAdjustAllConstMeta => const TaskConstMeta(
        debugName: "adjust_all",
        argNames: ["handle", "params"],
      );

  @override
  Future<void> crateAdjustBrightness(
      {required int handle, required int value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_i_32(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateAdjustBrightnessConstMeta,
      argValues: [handle, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateAdjustBrightnessConstMeta => const TaskConstMeta(
        debugName: "adjust_brightness",
        argNames: ["handle", "value"],
      );

  @override
  Future<void> crateAdjustContrast({required int handle, required int value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_i_32(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateAdjustContrastConstMeta,
      argValues: [handle, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateAdjustContrastConstMeta => const TaskConstMeta(
        debugName: "adjust_contrast",
        argNames: ["handle", "value"],
      );

  @override
  Future<void> crateAdjustHue({required int handle, required int value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_i_32(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateAdjustHueConstMeta,
      argValues: [handle, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateAdjustHueConstMeta => const TaskConstMeta(
        debugName: "adjust_hue",
        argNames: ["handle", "value"],
      );

  @override
  Future<void> crateAdjustSaturation(
      {required int handle, required int value}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_i_32(value, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateAdjustSaturationConstMeta,
      argValues: [handle, value],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateAdjustSaturationConstMeta => const TaskConstMeta(
        debugName: "adjust_saturation",
        argNames: ["handle", "value"],
      );

  @override
  Future<AdjustmentParams> crateImageManipulationAdjustmentParamsDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_adjustment_params,
        decodeErrorData: null,
      ),
      constMeta: kCrateImageManipulationAdjustmentParamsDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationAdjustmentParamsDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "adjustment_params_default",
        argNames: [],
      );

  @override
  Future<void> crateApplyFilter(
      {required int handle, required FilterType filter}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_filter_type(filter, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApplyFilterConstMeta,
      argValues: [handle, filter],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApplyFilterConstMeta => const TaskConstMeta(
        debugName: "apply_filter",
        argNames: ["handle", "filter"],
      );

  @override
  Future<void> crateBatchCropResizeAdjust(
      {required int handle,
      required CropParams cropParams,
      required int width,
      required int height,
      required ResizeFilter resizeFilter,
      required AdjustmentParams adjustments}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_box_autoadd_crop_params(cropParams, serializer);
        sse_encode_u_32(width, serializer);
        sse_encode_u_32(height, serializer);
        sse_encode_resize_filter(resizeFilter, serializer);
        sse_encode_box_autoadd_adjustment_params(adjustments, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateBatchCropResizeAdjustConstMeta,
      argValues: [handle, cropParams, width, height, resizeFilter, adjustments],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBatchCropResizeAdjustConstMeta => const TaskConstMeta(
        debugName: "batch_crop_resize_adjust",
        argNames: [
          "handle",
          "cropParams",
          "width",
          "height",
          "resizeFilter",
          "adjustments"
        ],
      );

  @override
  Future<void> crateBatchResizeAndFilter(
      {required int handle,
      required int width,
      required int height,
      required ResizeFilter filter,
      required FilterType imageFilter}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_u_32(width, serializer);
        sse_encode_u_32(height, serializer);
        sse_encode_resize_filter(filter, serializer);
        sse_encode_filter_type(imageFilter, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 38, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateBatchResizeAndFilterConstMeta,
      argValues: [handle, width, height, filter, imageFilter],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBatchResizeAndFilterConstMeta => const TaskConstMeta(
        debugName: "batch_resize_and_filter",
        argNames: ["handle", "width", "height", "filter", "imageFilter"],
      );

  @override
  Future<void> crateBlur({required int handle, required double sigma}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_f_32(sigma, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 39, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateBlurConstMeta,
      argValues: [handle, sigma],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateBlurConstMeta => const TaskConstMeta(
        debugName: "blur",
        argNames: ["handle", "sigma"],
      );

  @override
  Future<void> crateClearAllImages() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 40, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateClearAllImagesConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateClearAllImagesConstMeta => const TaskConstMeta(
        debugName: "clear_all_images",
        argNames: [],
      );

  @override
  Future<void> crateCrop({required int handle, required CropParams params}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_box_autoadd_crop_params(params, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 41, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateCropConstMeta,
      argValues: [handle, params],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateCropConstMeta => const TaskConstMeta(
        debugName: "crop",
        argNames: ["handle", "params"],
      );

  @override
  Future<void> crateDisposeImage({required int handle}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 42, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateDisposeImageConstMeta,
      argValues: [handle],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateDisposeImageConstMeta => const TaskConstMeta(
        debugName: "dispose_image",
        argNames: ["handle"],
      );

  @override
  Future<void> crateDisposeImages({required List<int> handles}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_32_loose(handles, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 43, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateDisposeImagesConstMeta,
      argValues: [handles],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateDisposeImagesConstMeta => const TaskConstMeta(
        debugName: "dispose_images",
        argNames: ["handles"],
      );

  @override
  Future<void> crateFlipHorizontal({required int handle}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 44, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateFlipHorizontalConstMeta,
      argValues: [handle],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateFlipHorizontalConstMeta => const TaskConstMeta(
        debugName: "flip_horizontal",
        argNames: ["handle"],
      );

  @override
  Future<void> crateFlipVertical({required int handle}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 45, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateFlipVerticalConstMeta,
      argValues: [handle],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateFlipVerticalConstMeta => const TaskConstMeta(
        debugName: "flip_vertical",
        argNames: ["handle"],
      );

  @override
  Future<CacheStats> crateGetCacheStats() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 46, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_cache_stats,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateGetCacheStatsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateGetCacheStatsConstMeta => const TaskConstMeta(
        debugName: "get_cache_stats",
        argNames: [],
      );

  @override
  Future<Uint8List> crateGetImageBytes(
      {required int handle, required ImageFormat format}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_image_format(format, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 47, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateGetImageBytesConstMeta,
      argValues: [handle, format],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateGetImageBytesConstMeta => const TaskConstMeta(
        debugName: "get_image_bytes",
        argNames: ["handle", "format"],
      );

  @override
  Future<(int, int)> crateGetImageDimensions({required int handle}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 48, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_u_32_u_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateGetImageDimensionsConstMeta,
      argValues: [handle],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateGetImageDimensionsConstMeta => const TaskConstMeta(
        debugName: "get_image_dimensions",
        argNames: ["handle"],
      );

  @override
  Future<void> crateGrayscale({required int handle}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 49, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateGrayscaleConstMeta,
      argValues: [handle],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateGrayscaleConstMeta => const TaskConstMeta(
        debugName: "grayscale",
        argNames: ["handle"],
      );

  @override
  Future<void> crateInitCache({required BigInt maxMemoryMb}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_usize(maxMemoryMb, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 50, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateInitCacheConstMeta,
      argValues: [maxMemoryMb],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateInitCacheConstMeta => const TaskConstMeta(
        debugName: "init_cache",
        argNames: ["maxMemoryMb"],
      );

  @override
  Future<void> crateInitializeCache() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 51, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateInitializeCacheConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateInitializeCacheConstMeta => const TaskConstMeta(
        debugName: "initialize_cache",
        argNames: [],
      );

  @override
  Future<void> crateInvert({required int handle}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 52, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateInvertConstMeta,
      argValues: [handle],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateInvertConstMeta => const TaskConstMeta(
        debugName: "invert",
        argNames: ["handle"],
      );

  @override
  Future<int> crateLoadImageFromBytes({required List<int> bytes}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(bytes, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 53, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateLoadImageFromBytesConstMeta,
      argValues: [bytes],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateLoadImageFromBytesConstMeta => const TaskConstMeta(
        debugName: "load_image_from_bytes",
        argNames: ["bytes"],
      );

  @override
  Future<int> crateLoadImageFromPath({required String path}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(path, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 54, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_32,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateLoadImageFromPathConstMeta,
      argValues: [path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateLoadImageFromPathConstMeta => const TaskConstMeta(
        debugName: "load_image_from_path",
        argNames: ["path"],
      );

  @override
  Future<void> crateOverlay(
      {required int handle,
      required int overlayHandle,
      required int x,
      required int y,
      required double opacity}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_u_32(overlayHandle, serializer);
        sse_encode_i_32(x, serializer);
        sse_encode_i_32(y, serializer);
        sse_encode_f_32(opacity, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 55, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateOverlayConstMeta,
      argValues: [handle, overlayHandle, x, y, opacity],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateOverlayConstMeta => const TaskConstMeta(
        debugName: "overlay",
        argNames: ["handle", "overlayHandle", "x", "y", "opacity"],
      );

  @override
  Future<void> crateResize(
      {required int handle,
      required int width,
      required int height,
      required ResizeFilter filter}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_u_32(width, serializer);
        sse_encode_u_32(height, serializer);
        sse_encode_resize_filter(filter, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 56, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateResizeConstMeta,
      argValues: [handle, width, height, filter],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateResizeConstMeta => const TaskConstMeta(
        debugName: "resize",
        argNames: ["handle", "width", "height", "filter"],
      );

  @override
  Future<void> crateResizeToFill(
      {required int handle,
      required int width,
      required int height,
      required ResizeFilter filter}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_u_32(width, serializer);
        sse_encode_u_32(height, serializer);
        sse_encode_resize_filter(filter, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 57, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateResizeToFillConstMeta,
      argValues: [handle, width, height, filter],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateResizeToFillConstMeta => const TaskConstMeta(
        debugName: "resize_to_fill",
        argNames: ["handle", "width", "height", "filter"],
      );

  @override
  Future<void> crateResizeToFit(
      {required int handle,
      required int maxWidth,
      required int maxHeight,
      required ResizeFilter filter}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_u_32(maxWidth, serializer);
        sse_encode_u_32(maxHeight, serializer);
        sse_encode_resize_filter(filter, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 58, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateResizeToFitConstMeta,
      argValues: [handle, maxWidth, maxHeight, filter],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateResizeToFitConstMeta => const TaskConstMeta(
        debugName: "resize_to_fit",
        argNames: ["handle", "maxWidth", "maxHeight", "filter"],
      );

  @override
  Future<void> crateRotate({required int handle, required int degrees}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_i_32(degrees, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 59, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateRotateConstMeta,
      argValues: [handle, degrees],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateRotateConstMeta => const TaskConstMeta(
        debugName: "rotate",
        argNames: ["handle", "degrees"],
      );

  @override
  Future<void> crateSharpen({required int handle, required double amount}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_u_32(handle, serializer);
        sse_encode_f_32(amount, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 60, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateSharpenConstMeta,
      argValues: [handle, amount],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateSharpenConstMeta => const TaskConstMeta(
        debugName: "sharpen",
        argNames: ["handle", "amount"],
      );

  @override
  Future<WatermarkParams> crateImageManipulationWatermarkParamsDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 61, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_watermark_params,
        decodeErrorData: null,
      ),
      constMeta: kCrateImageManipulationWatermarkParamsDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateImageManipulationWatermarkParamsDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "watermark_params_default",
        argNames: [],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ImageCache => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ImageCache => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  ImageCache
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ImageCacheImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ImageCache
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ImageCacheImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ImageCache
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ImageCacheImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ImageCache
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ImageCacheImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AdjustmentParams dco_decode_adjustment_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return AdjustmentParams(
      brightness: dco_decode_i_32(arr[0]),
      contrast: dco_decode_i_32(arr[1]),
      saturation: dco_decode_i_32(arr[2]),
      hue: dco_decode_i_32(arr[3]),
    );
  }

  @protected
  AdjustmentParams dco_decode_box_autoadd_adjustment_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_adjustment_params(raw);
  }

  @protected
  CropParams dco_decode_box_autoadd_crop_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_crop_params(raw);
  }

  @protected
  WatermarkParams dco_decode_box_autoadd_watermark_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_watermark_params(raw);
  }

  @protected
  CacheStats dco_decode_cache_stats(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return CacheStats(
      imageCount: dco_decode_usize(arr[0]),
      totalMemoryBytes: dco_decode_usize(arr[1]),
      averageMemoryPerImage: dco_decode_usize(arr[2]),
    );
  }

  @protected
  CropParams dco_decode_crop_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return CropParams(
      x: dco_decode_u_32(arr[0]),
      y: dco_decode_u_32(arr[1]),
      width: dco_decode_u_32(arr[2]),
      height: dco_decode_u_32(arr[3]),
    );
  }

  @protected
  double dco_decode_f_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as double;
  }

  @protected
  FilterType dco_decode_filter_type(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return FilterType.values[raw as int];
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  ImageFormat dco_decode_image_format(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ImageFormat.values[raw as int];
  }

  @protected
  List<int> dco_decode_list_prim_u_32_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint32List dco_decode_list_prim_u_32_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint32List;
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  Position dco_decode_position(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return const Position_TopLeft();
      case 1:
        return const Position_TopCenter();
      case 2:
        return const Position_TopRight();
      case 3:
        return const Position_CenterLeft();
      case 4:
        return const Position_Center();
      case 5:
        return const Position_CenterRight();
      case 6:
        return const Position_BottomLeft();
      case 7:
        return const Position_BottomCenter();
      case 8:
        return const Position_BottomRight();
      case 9:
        return Position_Custom(
          dco_decode_i_32(raw[1]),
          dco_decode_i_32(raw[2]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  (int, int) dco_decode_record_u_32_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_u_32(arr[0]),
      dco_decode_u_32(arr[1]),
    );
  }

  @protected
  ResizeFilter dco_decode_resize_filter(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ResizeFilter.values[raw as int];
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  WatermarkParams dco_decode_watermark_params(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return WatermarkParams(
      position: dco_decode_position(arr[0]),
      opacity: dco_decode_f_32(arr[1]),
      scale: dco_decode_f_32(arr[2]),
    );
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  ImageCache
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ImageCacheImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ImageCache
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ImageCacheImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ImageCache
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ImageCacheImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ImageCache
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ImageCacheImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AdjustmentParams sse_decode_adjustment_params(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_brightness = sse_decode_i_32(deserializer);
    var var_contrast = sse_decode_i_32(deserializer);
    var var_saturation = sse_decode_i_32(deserializer);
    var var_hue = sse_decode_i_32(deserializer);
    return AdjustmentParams(
        brightness: var_brightness,
        contrast: var_contrast,
        saturation: var_saturation,
        hue: var_hue);
  }

  @protected
  AdjustmentParams sse_decode_box_autoadd_adjustment_params(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_adjustment_params(deserializer));
  }

  @protected
  CropParams sse_decode_box_autoadd_crop_params(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_crop_params(deserializer));
  }

  @protected
  WatermarkParams sse_decode_box_autoadd_watermark_params(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_watermark_params(deserializer));
  }

  @protected
  CacheStats sse_decode_cache_stats(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_imageCount = sse_decode_usize(deserializer);
    var var_totalMemoryBytes = sse_decode_usize(deserializer);
    var var_averageMemoryPerImage = sse_decode_usize(deserializer);
    return CacheStats(
        imageCount: var_imageCount,
        totalMemoryBytes: var_totalMemoryBytes,
        averageMemoryPerImage: var_averageMemoryPerImage);
  }

  @protected
  CropParams sse_decode_crop_params(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_x = sse_decode_u_32(deserializer);
    var var_y = sse_decode_u_32(deserializer);
    var var_width = sse_decode_u_32(deserializer);
    var var_height = sse_decode_u_32(deserializer);
    return CropParams(x: var_x, y: var_y, width: var_width, height: var_height);
  }

  @protected
  double sse_decode_f_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getFloat32();
  }

  @protected
  FilterType sse_decode_filter_type(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return FilterType.values[inner];
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  ImageFormat sse_decode_image_format(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ImageFormat.values[inner];
  }

  @protected
  List<int> sse_decode_list_prim_u_32_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint32List(len_);
  }

  @protected
  Uint32List sse_decode_list_prim_u_32_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint32List(len_);
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Position sse_decode_position(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return const Position_TopLeft();
      case 1:
        return const Position_TopCenter();
      case 2:
        return const Position_TopRight();
      case 3:
        return const Position_CenterLeft();
      case 4:
        return const Position_Center();
      case 5:
        return const Position_CenterRight();
      case 6:
        return const Position_BottomLeft();
      case 7:
        return const Position_BottomCenter();
      case 8:
        return const Position_BottomRight();
      case 9:
        var var_field0 = sse_decode_i_32(deserializer);
        var var_field1 = sse_decode_i_32(deserializer);
        return Position_Custom(var_field0, var_field1);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  (int, int) sse_decode_record_u_32_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_u_32(deserializer);
    var var_field1 = sse_decode_u_32(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  ResizeFilter sse_decode_resize_filter(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return ResizeFilter.values[inner];
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  WatermarkParams sse_decode_watermark_params(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_position = sse_decode_position(deserializer);
    var var_opacity = sse_decode_f_32(deserializer);
    var var_scale = sse_decode_f_32(deserializer);
    return WatermarkParams(
        position: var_position, opacity: var_opacity, scale: var_scale);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
          ImageCache self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ImageCacheImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
          ImageCache self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ImageCacheImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
          ImageCache self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ImageCacheImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerImageCache(
          ImageCache self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ImageCacheImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_adjustment_params(
      AdjustmentParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.brightness, serializer);
    sse_encode_i_32(self.contrast, serializer);
    sse_encode_i_32(self.saturation, serializer);
    sse_encode_i_32(self.hue, serializer);
  }

  @protected
  void sse_encode_box_autoadd_adjustment_params(
      AdjustmentParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_adjustment_params(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_crop_params(
      CropParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_crop_params(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_watermark_params(
      WatermarkParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_watermark_params(self, serializer);
  }

  @protected
  void sse_encode_cache_stats(CacheStats self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(self.imageCount, serializer);
    sse_encode_usize(self.totalMemoryBytes, serializer);
    sse_encode_usize(self.averageMemoryPerImage, serializer);
  }

  @protected
  void sse_encode_crop_params(CropParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.x, serializer);
    sse_encode_u_32(self.y, serializer);
    sse_encode_u_32(self.width, serializer);
    sse_encode_u_32(self.height, serializer);
  }

  @protected
  void sse_encode_f_32(double self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putFloat32(self);
  }

  @protected
  void sse_encode_filter_type(FilterType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_image_format(ImageFormat self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_list_prim_u_32_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint32List(self is Uint32List ? self : Uint32List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_32_strict(
      Uint32List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint32List(self);
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_position(Position self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case Position_TopLeft():
        sse_encode_i_32(0, serializer);
      case Position_TopCenter():
        sse_encode_i_32(1, serializer);
      case Position_TopRight():
        sse_encode_i_32(2, serializer);
      case Position_CenterLeft():
        sse_encode_i_32(3, serializer);
      case Position_Center():
        sse_encode_i_32(4, serializer);
      case Position_CenterRight():
        sse_encode_i_32(5, serializer);
      case Position_BottomLeft():
        sse_encode_i_32(6, serializer);
      case Position_BottomCenter():
        sse_encode_i_32(7, serializer);
      case Position_BottomRight():
        sse_encode_i_32(8, serializer);
      case Position_Custom(field0: final field0, field1: final field1):
        sse_encode_i_32(9, serializer);
        sse_encode_i_32(field0, serializer);
        sse_encode_i_32(field1, serializer);
    }
  }

  @protected
  void sse_encode_record_u_32_u_32((int, int) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self.$1, serializer);
    sse_encode_u_32(self.$2, serializer);
  }

  @protected
  void sse_encode_resize_filter(ResizeFilter self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_watermark_params(
      WatermarkParams self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_position(self.position, serializer);
    sse_encode_f_32(self.opacity, serializer);
    sse_encode_f_32(self.scale, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }
}

@sealed
class ImageCacheImpl extends RustOpaque implements ImageCache {
  // Not to be used by end users
  ImageCacheImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ImageCacheImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ImageCache,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ImageCache,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ImageCachePtr,
  );

  Future<void> addWatermark(
          {required int handle,
          required int watermarkHandle,
          required WatermarkParams params}) =>
      RustLib.instance.api.crateImageManipulationImageCacheAddWatermark(
          that: this,
          handle: handle,
          watermarkHandle: watermarkHandle,
          params: params);

  Future<void> adjustAll(
          {required int handle, required AdjustmentParams params}) =>
      RustLib.instance.api.crateImageManipulationImageCacheAdjustAll(
          that: this, handle: handle, params: params);

  Future<void> adjustBrightness({required int handle, required int value}) =>
      RustLib.instance.api.crateImageManipulationImageCacheAdjustBrightness(
          that: this, handle: handle, value: value);

  Future<void> adjustContrast({required int handle, required int value}) =>
      RustLib.instance.api.crateImageManipulationImageCacheAdjustContrast(
          that: this, handle: handle, value: value);

  Future<void> adjustHue({required int handle, required int value}) =>
      RustLib.instance.api.crateImageManipulationImageCacheAdjustHue(
          that: this, handle: handle, value: value);

  Future<void> adjustSaturation({required int handle, required int value}) =>
      RustLib.instance.api.crateImageManipulationImageCacheAdjustSaturation(
          that: this, handle: handle, value: value);

  Future<void> applyFilter({required int handle, required FilterType filter}) =>
      RustLib.instance.api.crateImageManipulationImageCacheApplyFilter(
          that: this, handle: handle, filter: filter);

  Future<void> blur({required int handle, required double sigma}) =>
      RustLib.instance.api.crateImageManipulationImageCacheBlur(
          that: this, handle: handle, sigma: sigma);

  Future<void> clearAll() =>
      RustLib.instance.api.crateImageManipulationImageCacheClearAll(
        that: this,
      );

  Future<void> crop({required int handle, required CropParams params}) =>
      RustLib.instance.api.crateImageManipulationImageCacheCrop(
          that: this, handle: handle, params: params);

  Future<void> flipHorizontal({required int handle}) =>
      RustLib.instance.api.crateImageManipulationImageCacheFlipHorizontal(
          that: this, handle: handle);

  Future<void> flipVertical({required int handle}) => RustLib.instance.api
      .crateImageManipulationImageCacheFlipVertical(that: this, handle: handle);

  Future<Uint8List> getBytes(
          {required int handle, required ImageFormat format}) =>
      RustLib.instance.api.crateImageManipulationImageCacheGetBytes(
          that: this, handle: handle, format: format);

  Future<(int, int)> getDimensions({required int handle}) =>
      RustLib.instance.api.crateImageManipulationImageCacheGetDimensions(
          that: this, handle: handle);

  Future<CacheStats> getStats() =>
      RustLib.instance.api.crateImageManipulationImageCacheGetStats(
        that: this,
      );

  Future<void> grayscale({required int handle}) => RustLib.instance.api
      .crateImageManipulationImageCacheGrayscale(that: this, handle: handle);

  Future<void> invert({required int handle}) => RustLib.instance.api
      .crateImageManipulationImageCacheInvert(that: this, handle: handle);

  Future<int> loadFromBytes({required List<int> bytes}) => RustLib.instance.api
      .crateImageManipulationImageCacheLoadFromBytes(that: this, bytes: bytes);

  Future<int> loadFromPath({required String path}) => RustLib.instance.api
      .crateImageManipulationImageCacheLoadFromPath(that: this, path: path);

  Future<void> overlay(
          {required int handle,
          required int overlayHandle,
          required int x,
          required int y,
          required double opacity}) =>
      RustLib.instance.api.crateImageManipulationImageCacheOverlay(
          that: this,
          handle: handle,
          overlayHandle: overlayHandle,
          x: x,
          y: y,
          opacity: opacity);

  Future<void> remove({required int handle}) => RustLib.instance.api
      .crateImageManipulationImageCacheRemove(that: this, handle: handle);

  Future<void> resize(
          {required int handle,
          required int width,
          required int height,
          required ResizeFilter filter}) =>
      RustLib.instance.api.crateImageManipulationImageCacheResize(
          that: this,
          handle: handle,
          width: width,
          height: height,
          filter: filter);

  Future<void> resizeToFill(
          {required int handle,
          required int width,
          required int height,
          required ResizeFilter filter}) =>
      RustLib.instance.api.crateImageManipulationImageCacheResizeToFill(
          that: this,
          handle: handle,
          width: width,
          height: height,
          filter: filter);

  Future<void> resizeToFit(
          {required int handle,
          required int maxWidth,
          required int maxHeight,
          required ResizeFilter filter}) =>
      RustLib.instance.api.crateImageManipulationImageCacheResizeToFit(
          that: this,
          handle: handle,
          maxWidth: maxWidth,
          maxHeight: maxHeight,
          filter: filter);

  Future<void> rotate({required int handle, required int degrees}) =>
      RustLib.instance.api.crateImageManipulationImageCacheRotate(
          that: this, handle: handle, degrees: degrees);

  Future<void> sharpen({required int handle, required double amount}) =>
      RustLib.instance.api.crateImageManipulationImageCacheSharpen(
          that: this, handle: handle, amount: amount);
}
