// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'image_manipulation.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `CACHE`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `deref`, `fmt`, `initialize`

/// Initialise the cache with a custom memory limit.
/// Should be called once when the plugin starts.
Future<void> initCache({required BigInt maxMemoryMb}) =>
    RustLib.instance.api.crateInitCache(maxMemoryMb: maxMemoryMb);

/// Load an image from bytes and return a handle (receipt) to it
/// This is the "deposit" operation - stores image in native heap
Future<int> loadImageFromBytes({required List<int> bytes}) =>
    RustLib.instance.api.crateLoadImageFromBytes(bytes: bytes);

/// Load an image from a file path
Future<int> loadImageFromPath({required String path}) =>
    RustLib.instance.api.crateLoadImageFromPath(path: path);

/// Get the final processed image as bytes
/// This is the "withdrawal" operation - retrieves image from vault
Future<Uint8List> getImageBytes(
        {required int handle, required ImageFormat format}) =>
    RustLib.instance.api.crateGetImageBytes(handle: handle, format: format);

/// Get image dimensions (readâ€‘only, does not affect LRU order)
Future<(int, int)> getImageDimensions({required int handle}) =>
    RustLib.instance.api.crateGetImageDimensions(handle: handle);

/// Dispose of an image to free memory
/// CRITICAL: Must be called from Flutter's dispose() methods
Future<void> disposeImage({required int handle}) =>
    RustLib.instance.api.crateDisposeImage(handle: handle);

/// Dispose of multiple images at once
Future<void> disposeImages({required List<int> handles}) =>
    RustLib.instance.api.crateDisposeImages(handles: handles);

/// Clear all cached images - useful for memory cleanup
Future<void> clearAllImages() => RustLib.instance.api.crateClearAllImages();

/// Resize image to exact dimensions
Future<void> resize(
        {required int handle,
        required int width,
        required int height,
        required ResizeFilter filter}) =>
    RustLib.instance.api.crateResize(
        handle: handle, width: width, height: height, filter: filter);

/// Resize image maintaining aspect ratio (fit within bounds)
Future<void> resizeToFit(
        {required int handle,
        required int maxWidth,
        required int maxHeight,
        required ResizeFilter filter}) =>
    RustLib.instance.api.crateResizeToFit(
        handle: handle,
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        filter: filter);

/// Resize image maintaining aspect ratio (fill bounds, may crop)
Future<void> resizeToFill(
        {required int handle,
        required int width,
        required int height,
        required ResizeFilter filter}) =>
    RustLib.instance.api.crateResizeToFill(
        handle: handle, width: width, height: height, filter: filter);

/// Crop image to specified rectangle
Future<void> crop({required int handle, required CropParams params}) =>
    RustLib.instance.api.crateCrop(handle: handle, params: params);

/// Rotate image by 90, 180, or 270 degrees
Future<void> rotate({required int handle, required int degrees}) =>
    RustLib.instance.api.crateRotate(handle: handle, degrees: degrees);

/// Flip image horizontally
Future<void> flipHorizontal({required int handle}) =>
    RustLib.instance.api.crateFlipHorizontal(handle: handle);

/// Flip image vertically
Future<void> flipVertical({required int handle}) =>
    RustLib.instance.api.crateFlipVertical(handle: handle);

/// Apply a filter to the image
Future<void> applyFilter({required int handle, required FilterType filter}) =>
    RustLib.instance.api.crateApplyFilter(handle: handle, filter: filter);

/// Convert image to grayscale
Future<void> grayscale({required int handle}) =>
    RustLib.instance.api.crateGrayscale(handle: handle);

/// Invert image colors
Future<void> invert({required int handle}) =>
    RustLib.instance.api.crateInvert(handle: handle);

/// Apply Gaussian blur
Future<void> blur({required int handle, required double sigma}) =>
    RustLib.instance.api.crateBlur(handle: handle, sigma: sigma);

/// Sharpen image
Future<void> sharpen({required int handle, required double amount}) =>
    RustLib.instance.api.crateSharpen(handle: handle, amount: amount);

/// Adjust brightness (-100 to 100)
Future<void> adjustBrightness({required int handle, required int value}) =>
    RustLib.instance.api.crateAdjustBrightness(handle: handle, value: value);

/// Adjust contrast (-100 to 100)
Future<void> adjustContrast({required int handle, required int value}) =>
    RustLib.instance.api.crateAdjustContrast(handle: handle, value: value);

/// Adjust saturation (-100 to 100)
Future<void> adjustSaturation({required int handle, required int value}) =>
    RustLib.instance.api.crateAdjustSaturation(handle: handle, value: value);

/// Adjust hue (0 to 360 degrees)
Future<void> adjustHue({required int handle, required int value}) =>
    RustLib.instance.api.crateAdjustHue(handle: handle, value: value);

/// Apply multiple adjustments at once (more efficient)
Future<void> adjustAll(
        {required int handle, required AdjustmentParams params}) =>
    RustLib.instance.api.crateAdjustAll(handle: handle, params: params);

/// Add watermark to image
Future<void> addWatermark(
        {required int handle,
        required int watermarkHandle,
        required WatermarkParams params}) =>
    RustLib.instance.api.crateAddWatermark(
        handle: handle, watermarkHandle: watermarkHandle, params: params);

/// Overlay one image on top of another
Future<void> overlay(
        {required int handle,
        required int overlayHandle,
        required int x,
        required int y,
        required double opacity}) =>
    RustLib.instance.api.crateOverlay(
        handle: handle,
        overlayHandle: overlayHandle,
        x: x,
        y: y,
        opacity: opacity);

/// Batch operation: Resize and apply filter
Future<void> batchResizeAndFilter(
        {required int handle,
        required int width,
        required int height,
        required ResizeFilter filter,
        required FilterType imageFilter}) =>
    RustLib.instance.api.crateBatchResizeAndFilter(
        handle: handle,
        width: width,
        height: height,
        filter: filter,
        imageFilter: imageFilter);

/// Batch operation: Crop, resize, and adjust
Future<void> batchCropResizeAdjust(
        {required int handle,
        required CropParams cropParams,
        required int width,
        required int height,
        required ResizeFilter resizeFilter,
        required AdjustmentParams adjustments}) =>
    RustLib.instance.api.crateBatchCropResizeAdjust(
        handle: handle,
        cropParams: cropParams,
        width: width,
        height: height,
        resizeFilter: resizeFilter,
        adjustments: adjustments);

/// Get memory usage statistics
Future<CacheStats> getCacheStats() => RustLib.instance.api.crateGetCacheStats();

/// Pre-warm the cache with common operations (optional optimization)
Future<void> initializeCache() => RustLib.instance.api.crateInitializeCache();

class CacheStats {
  final BigInt imageCount;
  final BigInt totalMemoryBytes;
  final BigInt averageMemoryPerImage;

  const CacheStats({
    required this.imageCount,
    required this.totalMemoryBytes,
    required this.averageMemoryPerImage,
  });

  @override
  int get hashCode =>
      imageCount.hashCode ^
      totalMemoryBytes.hashCode ^
      averageMemoryPerImage.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CacheStats &&
          runtimeType == other.runtimeType &&
          imageCount == other.imageCount &&
          totalMemoryBytes == other.totalMemoryBytes &&
          averageMemoryPerImage == other.averageMemoryPerImage;
}
