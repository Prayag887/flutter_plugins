// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'image_manipulation.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `adjust_contrast_impl`, `adjust_hue_impl`, `adjust_saturation_impl`, `apply_emboss`, `apply_sepia_native`, `apply_sharpen`, `apply_sobel_edge_detection`, `composite_overlay`, `composite_watermark`, `edge_detect`, `emboss`, `evict_if_needed`, `generate_id`, `hsl_to_rgb`, `image_memory`, `resize_simd`, `rgb_to_hsl`, `sepia`, `to_fr_filter`, `to_image_format`, `touch`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<ImageCache>>
abstract class ImageCache implements RustOpaqueInterface {
  Future<void> addWatermark(
      {required int handle,
      required int watermarkHandle,
      required WatermarkParams params});

  Future<void> adjustAll(
      {required int handle, required AdjustmentParams params});

  Future<void> adjustBrightness({required int handle, required int value});

  Future<void> adjustContrast({required int handle, required int value});

  Future<void> adjustHue({required int handle, required int value});

  Future<void> adjustSaturation({required int handle, required int value});

  Future<void> applyFilter({required int handle, required FilterType filter});

  Future<void> blur({required int handle, required double sigma});

  Future<void> clearAll();

  Future<void> crop({required int handle, required CropParams params});

  Future<void> flipHorizontal({required int handle});

  Future<void> flipVertical({required int handle});

  Future<Uint8List> getBytes(
      {required int handle, required ImageFormat format});

  Future<(int, int)> getDimensions({required int handle});

  Future<CacheStats> getStats();

  Future<void> grayscale({required int handle});

  Future<void> invert({required int handle});

  Future<int> loadFromBytes({required List<int> bytes});

  Future<int> loadFromPath({required String path});

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<ImageCache> newInstance() =>
      RustLib.instance.api.crateImageManipulationImageCacheNew();

  Future<void> overlay(
      {required int handle,
      required int overlayHandle,
      required int x,
      required int y,
      required double opacity});

  Future<void> remove({required int handle});

  Future<void> resize(
      {required int handle,
      required int width,
      required int height,
      required ResizeFilter filter});

  Future<void> resizeToFill(
      {required int handle,
      required int width,
      required int height,
      required ResizeFilter filter});

  Future<void> resizeToFit(
      {required int handle,
      required int maxWidth,
      required int maxHeight,
      required ResizeFilter filter});

  Future<void> rotate({required int handle, required int degrees});

  Future<void> sharpen({required int handle, required double amount});

  static Future<ImageCache> withMemoryLimit({required BigInt maxMemoryBytes}) =>
      RustLib.instance.api.crateImageManipulationImageCacheWithMemoryLimit(
          maxMemoryBytes: maxMemoryBytes);
}

class AdjustmentParams {
  final int brightness;
  final int contrast;
  final int saturation;
  final int hue;

  const AdjustmentParams({
    required this.brightness,
    required this.contrast,
    required this.saturation,
    required this.hue,
  });

  static Future<AdjustmentParams> default_() =>
      RustLib.instance.api.crateImageManipulationAdjustmentParamsDefault();

  @override
  int get hashCode =>
      brightness.hashCode ^
      contrast.hashCode ^
      saturation.hashCode ^
      hue.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AdjustmentParams &&
          runtimeType == other.runtimeType &&
          brightness == other.brightness &&
          contrast == other.contrast &&
          saturation == other.saturation &&
          hue == other.hue;
}

class CropParams {
  final int x;
  final int y;
  final int width;
  final int height;

  const CropParams({
    required this.x,
    required this.y,
    required this.width,
    required this.height,
  });

  @override
  int get hashCode =>
      x.hashCode ^ y.hashCode ^ width.hashCode ^ height.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CropParams &&
          runtimeType == other.runtimeType &&
          x == other.x &&
          y == other.y &&
          width == other.width &&
          height == other.height;
}

enum FilterType {
  grayscale,
  sepia,
  invert,
  blur,
  sharpen,
  edgeDetect,
  emboss,
  ;
}

enum ImageFormat {
  png,
  jpeg,
  webP,
  gif,
  bmp,
  ;
}

@freezed
sealed class Position with _$Position {
  const Position._();

  const factory Position.topLeft() = Position_TopLeft;
  const factory Position.topCenter() = Position_TopCenter;
  const factory Position.topRight() = Position_TopRight;
  const factory Position.centerLeft() = Position_CenterLeft;
  const factory Position.center() = Position_Center;
  const factory Position.centerRight() = Position_CenterRight;
  const factory Position.bottomLeft() = Position_BottomLeft;
  const factory Position.bottomCenter() = Position_BottomCenter;
  const factory Position.bottomRight() = Position_BottomRight;
  const factory Position.custom(
    int field0,
    int field1,
  ) = Position_Custom;
}

enum ResizeFilter {
  nearest,
  bilinear,
  catmullRom,
  lanczos3,
  ;
}

class WatermarkParams {
  final Position position;
  final double opacity;
  final double scale;

  const WatermarkParams({
    required this.position,
    required this.opacity,
    required this.scale,
  });

  static Future<WatermarkParams> default_() =>
      RustLib.instance.api.crateImageManipulationWatermarkParamsDefault();

  @override
  int get hashCode => position.hashCode ^ opacity.hashCode ^ scale.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WatermarkParams &&
          runtimeType == other.runtimeType &&
          position == other.position &&
          opacity == other.opacity &&
          scale == other.scale;
}
